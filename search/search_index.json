{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Double Precision Maths Library","text":""},{"location":"#overview","title":"Overview","text":"<p>This is the documentation for the Double Precision Maths Library - a library of code for users of the Unity game engine. </p> <p>The library is designed to offer classes that are instantly familiar to Unity users, as each class in this library has a corresponding equivalent class in the core UnityEngine API. However, the crucial difference is that while the Unity classes are built using single precision floating-point numbers, this library provides those same classes with double precision floating point numbers.</p> <p>The classes provided by this library are:</p> <ul> <li>Mathd</li> <li>Matrix4x4d</li> <li>Quaterniond</li> <li>Vector2d</li> <li>Vector3d</li> <li>Vector4d</li> </ul>"},{"location":"#purpose-of-this-package","title":"Purpose Of This Package","text":"<p>Compared to the C# <code>float</code> type, the <code>double</code> type allows for calculations to be made with greater precision, and reduces the potential impact of floating-point rounding errors in long calculations. </p> <p>For example, when simulating the orbital mechanics of the solar system you might have a satellite that is hundreds of millions of metres away from the Sun, but you would still like to know its location down to the centimetre. Single precision floats will struggle in this scenario without workarounds, while double precision floats will happily cover the extreme range of values. </p> <p>This of course comes at the cost of some speed and doubled memory usage. </p>"},{"location":"#installation","title":"Installation","text":"<p>The package may installed from the Unity Asset Store for $5.</p>"},{"location":"#style-of-this-documentation","title":"Style Of This Documentation","text":"<p>The classes of this library are intended to match their Unity equivalents as closely as possible. Because of this, the documentation provided by Unity can largely serve as the documentation for this library.</p> <p>However, there are cases where the interfaces don't match. For example, there may be small differences in convention when returning values from some methods, or there are some methods which are simply not implemented by this library. This documentation seeks only to record those differences, no matter how big or small.</p> <p>In general, methods were not implemented for one of two reasons:</p> <ol> <li>A double precision version of a method seemed to offer little practical benefit. </li> <li>I was unable to recreate the equivalent Unity method with enough accuracy.</li> </ol> <p>If there is an unimplemented method that you wish was included, or you find a difference between the implementations that isn't recorded here, please get in touch and I can look into it!</p>"},{"location":"Mathd/","title":"Mathd","text":""},{"location":"Mathd/#unity-equivalent-documentation","title":"Unity Equivalent Documentation","text":"<ul> <li>Unity <code>Mathf</code> Documentation</li> </ul>"},{"location":"Mathd/#unimplemented-methods","title":"Unimplemented Methods","text":"<p>Static Methods</p> <ul> <li><code>CorrelatedColorTemperatureToRGB()</code></li> <li><code>DoubleToHalf()</code></li> <li><code>GammaToLinearSpace()</code></li> <li><code>HalfToDouble()</code></li> <li><code>IsPowerOfTwo()</code></li> <li><code>LinearToGammaSpace()</code></li> <li><code>NextPowerOfTwo()</code></li> <li><code>PerlinNoise()</code></li> <li><code>PerlinNoise1D()</code></li> <li><code>SmoothDamp()</code></li> <li><code>SmoothDampAngle()</code></li> <li><code>SmoothStep()</code></li> </ul>"},{"location":"Mathd/#known-differences-between-the-implementations","title":"Known Differences Between The Implementations","text":"<p>None.</p>"},{"location":"Matrix4x4d/","title":"Matrix4x4d","text":""},{"location":"Matrix4x4d/#unity-equivalent-documentation","title":"Unity Equivalent Documentation","text":"<ul> <li>Unity <code>Matrix4x4</code> Documentation</li> </ul>"},{"location":"Matrix4x4d/#unimplemented-methods","title":"Unimplemented Methods","text":"<p>None.</p>"},{"location":"Matrix4x4d/#known-differences-between-the-implementations","title":"Known Differences Between The Implementations","text":"<p>Equality Checking</p> <p>While the Unity <code>Matrix4x4</code> class does have implementations for the <code>==</code> and <code>!=</code> operators, there isn't any documentation on them. The same is true for the <code>Equals()</code> method.</p> <p>I have implemented it such that the operators check for approximate equality, while the <code>Equals()</code> method checks for exact equality. This is what I believe the Unity implementation is. </p> <p>Static Methods</p> <ul> <li><code>TRS()</code> - When the Unity method is provided a non-unit quaternion, an error is thrown and some matrix is constructed. The implementation used in this package also throws an error and produces some matrix, and that matrix will generally not match the matrix produced by the Unity method.</li> </ul> <p>Instance Methods</p> <ul> <li><code>SetTRS()</code> - When the Unity method is provided a non-unit quaternion, an error is thrown and some matrix is constructed. The implementation used in this package normalises the quaternion to construct a valid TRS matrix.</li> </ul> <p>Properties</p> <ul> <li><code>decomposeProjection</code> - When given a random matrix (not necessarily a projection matrix) the returned frustrum planes do not match. However, this property is generally expected to be used on a projection matrix, and in that case the implementations do match.</li> <li><code>rotation</code> - There are cases when the returned quaternion does not match. This happens when the matrix contains a net reflection in its scale vector (see <code>lossyScale</code> property). The issue is that a reflection in any one axis is equivalent to a different reflection and a rotation. Thus any given TRS matrix with a net reflection could've been constructed by multiple input scale vectors and rotation quaternions. My implementation assumes that the reflection occured in the x-axis, and returns the corresponding rotation. The Unity implementation appears to vary which axis it considers the reflection to have occurred upon.</li> </ul>"},{"location":"Quaterniond/","title":"Quaterniond","text":""},{"location":"Quaterniond/#unity-equivalent-documentation","title":"Unity Equivalent Documentation","text":"<ul> <li>Unity <code>Quaternion</code> Documentation</li> </ul>"},{"location":"Quaterniond/#unimplemented-methods","title":"Unimplemented Methods","text":"<p>Instance Methods</p> <ul> <li><code>RotateTowards()</code></li> </ul>"},{"location":"Quaterniond/#known-differences-between-the-implementations","title":"Known Differences Between The Implementations","text":"<p>Static Methods</p> <ul> <li><code>Slerp()</code> - In the case where the two input rotations are separated by 180\u00b0, there is no unique path to take between the two rotations. On most calls the library's implementation will return the same rotation as the Unity rotation, but on some rare occasions the rotations will differ.</li> <li><code>SlerpUnclamped()</code> - Same as above.</li> </ul>"},{"location":"Vector2d/","title":"Vector2d","text":""},{"location":"Vector2d/#unity-equivalent-documentation","title":"Unity Equivalent Documentation","text":"<ul> <li>Unity <code>Vector2</code> Documentation</li> </ul>"},{"location":"Vector2d/#unimplemented-methods","title":"Unimplemented Methods","text":"<p>Static Methods</p> <ul> <li><code>SmoothDamp()</code></li> </ul>"},{"location":"Vector2d/#known-differences-between-the-implementations","title":"Known Differences Between The Implementations","text":"<p>None.</p>"},{"location":"Vector3d/","title":"Vector3d","text":""},{"location":"Vector3d/#unity-equivalent-documentation","title":"Unity Equivalent Documentation","text":"<ul> <li>Unity <code>Vector3</code> Documentation</li> </ul>"},{"location":"Vector3d/#unimplemented-methods","title":"Unimplemented Methods","text":"<p>Instance Methods</p> <ul> <li><code>RotateTowards()</code></li> </ul> <p>Static Methods</p> <ul> <li><code>SmoothDamp()</code></li> </ul>"},{"location":"Vector3d/#known-differences-between-the-implementations","title":"Known Differences Between The Implementations","text":"<p>Static Methods</p> <ul> <li><code>Slerp()</code> - In the case where the two input vectors are separated by 180\u00b0, there is no unique path to take between the two vectors. This library will produce a valid Slerp that matches the definition in the Unity documentation, but that Slerp will generally not be exactly the same as that produced by the Unity method.</li> <li><code>SlerpUnclamped()</code> - Same as above.</li> </ul>"},{"location":"Vector4d/","title":"Vector4d","text":""},{"location":"Vector4d/#unity-equivalent-documentation","title":"Unity Equivalent Documentation","text":"<ul> <li>Unity <code>Vector4</code> Documentation</li> </ul>"},{"location":"Vector4d/#unimplemented-methods","title":"Unimplemented Methods","text":"<p>None.</p>"},{"location":"Vector4d/#known-differences-between-the-implementations","title":"Known Differences Between The Implementations","text":"<p>None.</p>"}]}